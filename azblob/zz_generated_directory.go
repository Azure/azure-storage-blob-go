package azblob

// todo funky directory code
//
// // Code generated by Microsoft (R) AutoRest Code Generator.
// // Changes may cause incorrect behavior and will be lost if the code is regenerated.
//
// import (
// 	"context"
// 	"github.com/Azure/azure-pipeline-go/pipeline"
// 	"io"
// 	"io/ioutil"
// 	"net/http"
// 	"net/url"
// 	"strconv"
// 	"time"
// )
//
// // directoryClient is the client for the Directory methods of the Azblob service.
// type directoryClient struct {
// 	managementClient
// }
//
// // newDirectoryClient creates an instance of the directoryClient client.
// func newDirectoryClient(url url.URL, p pipeline.Pipeline) directoryClient {
// 	return directoryClient{newManagementClient(url, p)}
// }
//
// // Create create a directory. By default, the destination is overwritten and if the destination already exists and has
// // a lease the lease is broken. This operation supports conditional HTTP requests.  For more information, see
// // [Specifying Conditional Headers for Blob Service
// // Operations](https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).
// // To fail if the destination already exists, use a conditional request with If-None-Match: "*".
// //
// // timeout is the timeout parameter is expressed in seconds. For more information, see <a
// // href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
// // Timeouts for Blob Service Operations.</a> directoryProperties is optional.  User-defined properties to be stored
// // with the file or directory, in the format of a comma-separated list of name and value pairs "n1=v1, n2=v2, ...",
// // where each value is base64 encoded. posixPermissions is optional and only valid if Hierarchical Namespace is enabled
// // for the account. Sets POSIX access permissions for the file owner, the file owning group, and others. Each class may
// // be granted read, write, or execute permission.  The sticky bit is also supported.  Both symbolic (rwxrw-rw-) and
// // 4-digit octal notation (e.g. 0766) are supported. posixUmask is only valid if Hierarchical Namespace is enabled for
// // the account. This umask restricts permission settings for file and directory, and will only be applied when default
// // Acl does not exist in parent directory. If the umask bit has set, it means that the corresponding permission will be
// // disabled. Otherwise the corresponding permission will be determined by the permission. A 4-digit octal notation
// // (e.g. 0022) is supported here. If no umask was specified, a default umask - 0027 will be used. cacheControl is cache
// // control for given resource contentType is content type for given resource contentEncoding is content encoding for
// // given resource contentLanguage is content language for given resource contentDisposition is content disposition for
// // given resource leaseID is if specified, the operation only succeeds if the resource's lease is active and matches
// // this ID. ifModifiedSince is specify this header value to operate only on a blob if it has been modified since the
// // specified date/time. ifUnmodifiedSince is specify this header value to operate only on a blob if it has not been
// // modified since the specified date/time. ifMatch is specify an ETag value to operate only on blobs with a matching
// // value. ifNoneMatch is specify an ETag value to operate only on blobs without a matching value. requestID is provides
// // a client-generated, opaque value with a 1 KB character limit that is recorded in the analytics logs when storage
// // analytics logging is enabled.
// func (client directoryClient) Create(ctx context.Context, timeout *int32, directoryProperties *string, posixPermissions *string, posixUmask *string, cacheControl *string, contentType *string, contentEncoding *string, contentLanguage *string, contentDisposition *string, leaseID *string, ifModifiedSince *time.Time, ifUnmodifiedSince *time.Time, ifMatch *ETag, ifNoneMatch *ETag, requestID *string) (*DirectoryCreateResponse, error) {
// 	if err := validate([]validation{
// 		{targetValue: timeout,
// 			constraints: []constraint{{target: "timeout", name: null, rule: false,
// 				chain: []constraint{{target: "timeout", name: inclusiveMinimum, rule: 0, chain: nil}}}}}}); err != nil {
// 		return nil, err
// 	}
// 	req, err := client.createPreparer(timeout, directoryProperties, posixPermissions, posixUmask, cacheControl, contentType, contentEncoding, contentLanguage, contentDisposition, leaseID, ifModifiedSince, ifUnmodifiedSince, ifMatch, ifNoneMatch, requestID)
// 	if err != nil {
// 		return nil, err
// 	}
// 	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.createResponder}, req)
// 	if err != nil {
// 		return nil, err
// 	}
// 	return resp.(*DirectoryCreateResponse), err
// }
//
// // createPreparer prepares the Create request.
// func (client directoryClient) createPreparer(timeout *int32, directoryProperties *string, posixPermissions *string, posixUmask *string, cacheControl *string, contentType *string, contentEncoding *string, contentLanguage *string, contentDisposition *string, leaseID *string, ifModifiedSince *time.Time, ifUnmodifiedSince *time.Time, ifMatch *ETag, ifNoneMatch *ETag, requestID *string) (pipeline.Request, error) {
// 	req, err := pipeline.NewRequest("PUT", client.url, nil)
// 	if err != nil {
// 		return req, pipeline.NewError(err, "failed to create request")
// 	}
// 	params := req.URL.Query()
// 	if timeout != nil {
// 		params.Set("timeout", strconv.FormatInt(int64(*timeout), 10))
// 	}
// 	params.Set("resource", "directory")
// 	req.URL.RawQuery = params.Encode()
// 	if directoryProperties != nil {
// 		req.Header.Set("x-ms-properties", *directoryProperties)
// 	}
// 	if posixPermissions != nil {
// 		req.Header.Set("x-ms-permissions", *posixPermissions)
// 	}
// 	if posixUmask != nil {
// 		req.Header.Set("x-ms-umask", *posixUmask)
// 	}
// 	if cacheControl != nil {
// 		req.Header.Set("x-ms-cache-control", *cacheControl)
// 	}
// 	if contentType != nil {
// 		req.Header.Set("x-ms-content-type", *contentType)
// 	}
// 	if contentEncoding != nil {
// 		req.Header.Set("x-ms-content-encoding", *contentEncoding)
// 	}
// 	if contentLanguage != nil {
// 		req.Header.Set("x-ms-content-language", *contentLanguage)
// 	}
// 	if contentDisposition != nil {
// 		req.Header.Set("x-ms-content-disposition", *contentDisposition)
// 	}
// 	if leaseID != nil {
// 		req.Header.Set("x-ms-lease-id", *leaseID)
// 	}
// 	if ifModifiedSince != nil {
// 		req.Header.Set("If-Modified-Since", (*ifModifiedSince).In(gmt).Format(time.RFC1123))
// 	}
// 	if ifUnmodifiedSince != nil {
// 		req.Header.Set("If-Unmodified-Since", (*ifUnmodifiedSince).In(gmt).Format(time.RFC1123))
// 	}
// 	if ifMatch != nil {
// 		req.Header.Set("If-Match", string(*ifMatch))
// 	}
// 	if ifNoneMatch != nil {
// 		req.Header.Set("If-None-Match", string(*ifNoneMatch))
// 	}
// 	req.Header.Set("x-ms-version", ServiceVersion)
// 	if requestID != nil {
// 		req.Header.Set("x-ms-client-request-id", *requestID)
// 	}
// 	return req, nil
// }
//
// // createResponder handles the response to the Create request.
// func (client directoryClient) createResponder(resp pipeline.Response) (pipeline.Response, error) {
// 	err := validateResponse(resp, http.StatusOK, http.StatusCreated)
// 	if resp == nil {
// 		return nil, err
// 	}
// 	io.Copy(ioutil.Discard, resp.Response().Body)
// 	resp.Response().Body.Close()
// 	return &DirectoryCreateResponse{rawResponse: resp.Response()}, err
// }
//
// // Delete deletes the directory
// //
// // recursiveDirectoryDelete is if "true", all paths beneath the directory will be deleted. If "false" and the directory
// // is non-empty, an error occurs. timeout is the timeout parameter is expressed in seconds. For more information, see
// // <a
// // href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
// // Timeouts for Blob Service Operations.</a> marker is when renaming a directory, the number of paths that are renamed
// // with each invocation is limited.  If the number of paths to be renamed exceeds this limit, a continuation token is
// // returned in this response header.  When a continuation token is returned in the response, it must be specified in a
// // subsequent invocation of the rename operation to continue renaming the directory. leaseID is if specified, the
// // operation only succeeds if the resource's lease is active and matches this ID. ifModifiedSince is specify this
// // header value to operate only on a blob if it has been modified since the specified date/time. ifUnmodifiedSince is
// // specify this header value to operate only on a blob if it has not been modified since the specified date/time.
// // ifMatch is specify an ETag value to operate only on blobs with a matching value. ifNoneMatch is specify an ETag
// // value to operate only on blobs without a matching value. requestID is provides a client-generated, opaque value with
// // a 1 KB character limit that is recorded in the analytics logs when storage analytics logging is enabled.
// func (client directoryClient) Delete(ctx context.Context, recursiveDirectoryDelete bool, timeout *int32, marker *string, leaseID *string, ifModifiedSince *time.Time, ifUnmodifiedSince *time.Time, ifMatch *ETag, ifNoneMatch *ETag, requestID *string) (*DirectoryDeleteResponse, error) {
// 	if err := validate([]validation{
// 		{targetValue: timeout,
// 			constraints: []constraint{{target: "timeout", name: null, rule: false,
// 				chain: []constraint{{target: "timeout", name: inclusiveMinimum, rule: 0, chain: nil}}}}}}); err != nil {
// 		return nil, err
// 	}
// 	req, err := client.deletePreparer(recursiveDirectoryDelete, timeout, marker, leaseID, ifModifiedSince, ifUnmodifiedSince, ifMatch, ifNoneMatch, requestID)
// 	if err != nil {
// 		return nil, err
// 	}
// 	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.deleteResponder}, req)
// 	if err != nil {
// 		return nil, err
// 	}
// 	return resp.(*DirectoryDeleteResponse), err
// }
//
// // deletePreparer prepares the Delete request.
// func (client directoryClient) deletePreparer(recursiveDirectoryDelete bool, timeout *int32, marker *string, leaseID *string, ifModifiedSince *time.Time, ifUnmodifiedSince *time.Time, ifMatch *ETag, ifNoneMatch *ETag, requestID *string) (pipeline.Request, error) {
// 	req, err := pipeline.NewRequest("DELETE", client.url, nil)
// 	if err != nil {
// 		return req, pipeline.NewError(err, "failed to create request")
// 	}
// 	params := req.URL.Query()
// 	if timeout != nil {
// 		params.Set("timeout", strconv.FormatInt(int64(*timeout), 10))
// 	}
// 	params.Set("recursive", strconv.FormatBool(recursiveDirectoryDelete))
// 	if marker != nil && len(*marker) > 0 {
// 		params.Set("continuation", *marker)
// 	}
// 	req.URL.RawQuery = params.Encode()
// 	if leaseID != nil {
// 		req.Header.Set("x-ms-lease-id", *leaseID)
// 	}
// 	if ifModifiedSince != nil {
// 		req.Header.Set("If-Modified-Since", (*ifModifiedSince).In(gmt).Format(time.RFC1123))
// 	}
// 	if ifUnmodifiedSince != nil {
// 		req.Header.Set("If-Unmodified-Since", (*ifUnmodifiedSince).In(gmt).Format(time.RFC1123))
// 	}
// 	if ifMatch != nil {
// 		req.Header.Set("If-Match", string(*ifMatch))
// 	}
// 	if ifNoneMatch != nil {
// 		req.Header.Set("If-None-Match", string(*ifNoneMatch))
// 	}
// 	req.Header.Set("x-ms-version", ServiceVersion)
// 	if requestID != nil {
// 		req.Header.Set("x-ms-client-request-id", *requestID)
// 	}
// 	return req, nil
// }
//
// // deleteResponder handles the response to the Delete request.
// func (client directoryClient) deleteResponder(resp pipeline.Response) (pipeline.Response, error) {
// 	err := validateResponse(resp, http.StatusOK)
// 	if resp == nil {
// 		return nil, err
// 	}
// 	io.Copy(ioutil.Discard, resp.Response().Body)
// 	resp.Response().Body.Close()
// 	return &DirectoryDeleteResponse{rawResponse: resp.Response()}, err
// }
//
// // GetAccessControl get the owner, group, permissions, or access control list for a directory.
// //
// // timeout is the timeout parameter is expressed in seconds. For more information, see <a
// // href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
// // Timeouts for Blob Service Operations.</a> upn is optional. Valid only when Hierarchical Namespace is enabled for the
// // account. If "true", the identity values returned in the x-ms-owner, x-ms-group, and x-ms-acl response headers will
// // be transformed from Azure Active Directory Object IDs to User Principal Names.  If "false", the values will be
// // returned as Azure Active Directory Object IDs. The default value is false. leaseID is if specified, the operation
// // only succeeds if the resource's lease is active and matches this ID. ifMatch is specify an ETag value to operate
// // only on blobs with a matching value. ifNoneMatch is specify an ETag value to operate only on blobs without a
// // matching value. ifModifiedSince is specify this header value to operate only on a blob if it has been modified since
// // the specified date/time. ifUnmodifiedSince is specify this header value to operate only on a blob if it has not been
// // modified since the specified date/time. requestID is provides a client-generated, opaque value with a 1 KB character
// // limit that is recorded in the analytics logs when storage analytics logging is enabled.
// func (client directoryClient) GetAccessControl(ctx context.Context, timeout *int32, upn *bool, leaseID *string, ifMatch *ETag, ifNoneMatch *ETag, ifModifiedSince *time.Time, ifUnmodifiedSince *time.Time, requestID *string) (*DirectoryGetAccessControlResponse, error) {
// 	if err := validate([]validation{
// 		{targetValue: timeout,
// 			constraints: []constraint{{target: "timeout", name: null, rule: false,
// 				chain: []constraint{{target: "timeout", name: inclusiveMinimum, rule: 0, chain: nil}}}}}}); err != nil {
// 		return nil, err
// 	}
// 	req, err := client.getAccessControlPreparer(timeout, upn, leaseID, ifMatch, ifNoneMatch, ifModifiedSince, ifUnmodifiedSince, requestID)
// 	if err != nil {
// 		return nil, err
// 	}
// 	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.getAccessControlResponder}, req)
// 	if err != nil {
// 		return nil, err
// 	}
// 	return resp.(*DirectoryGetAccessControlResponse), err
// }
//
// // getAccessControlPreparer prepares the GetAccessControl request.
// func (client directoryClient) getAccessControlPreparer(timeout *int32, upn *bool, leaseID *string, ifMatch *ETag, ifNoneMatch *ETag, ifModifiedSince *time.Time, ifUnmodifiedSince *time.Time, requestID *string) (pipeline.Request, error) {
// 	req, err := pipeline.NewRequest("HEAD", client.url, nil)
// 	if err != nil {
// 		return req, pipeline.NewError(err, "failed to create request")
// 	}
// 	params := req.URL.Query()
// 	if timeout != nil {
// 		params.Set("timeout", strconv.FormatInt(int64(*timeout), 10))
// 	}
// 	if upn != nil {
// 		params.Set("upn", strconv.FormatBool(*upn))
// 	}
// 	params.Set("action", "getAccessControl")
// 	req.URL.RawQuery = params.Encode()
// 	if leaseID != nil {
// 		req.Header.Set("x-ms-lease-id", *leaseID)
// 	}
// 	if ifMatch != nil {
// 		req.Header.Set("If-Match", string(*ifMatch))
// 	}
// 	if ifNoneMatch != nil {
// 		req.Header.Set("If-None-Match", string(*ifNoneMatch))
// 	}
// 	if ifModifiedSince != nil {
// 		req.Header.Set("If-Modified-Since", (*ifModifiedSince).In(gmt).Format(time.RFC1123))
// 	}
// 	if ifUnmodifiedSince != nil {
// 		req.Header.Set("If-Unmodified-Since", (*ifUnmodifiedSince).In(gmt).Format(time.RFC1123))
// 	}
// 	if requestID != nil {
// 		req.Header.Set("x-ms-client-request-id", *requestID)
// 	}
// 	req.Header.Set("x-ms-version", ServiceVersion)
// 	return req, nil
// }
//
// // getAccessControlResponder handles the response to the GetAccessControl request.
// func (client directoryClient) getAccessControlResponder(resp pipeline.Response) (pipeline.Response, error) {
// 	err := validateResponse(resp, http.StatusOK)
// 	if resp == nil {
// 		return nil, err
// 	}
// 	io.Copy(ioutil.Discard, resp.Response().Body)
// 	resp.Response().Body.Close()
// 	return &DirectoryGetAccessControlResponse{rawResponse: resp.Response()}, err
// }
//
// // Rename rename a directory. By default, the destination is overwritten and if the destination already exists and has
// // a lease the lease is broken. This operation supports conditional HTTP requests. For more information, see
// // [Specifying Conditional Headers for Blob Service
// // Operations](https://docs.microsoft.com/en-us/rest/api/storageservices/specifying-conditional-headers-for-blob-service-operations).
// // To fail if the destination already exists, use a conditional request with If-None-Match: "*".
// //
// // renameSource is the file or directory to be renamed. The value must have the following format:
// // "/{filesysystem}/{path}".  If "x-ms-properties" is specified, the properties will overwrite the existing properties;
// // otherwise, the existing properties will be preserved. timeout is the timeout parameter is expressed in seconds. For
// // more information, see <a
// // href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
// // Timeouts for Blob Service Operations.</a> marker is when renaming a directory, the number of paths that are renamed
// // with each invocation is limited.  If the number of paths to be renamed exceeds this limit, a continuation token is
// // returned in this response header.  When a continuation token is returned in the response, it must be specified in a
// // subsequent invocation of the rename operation to continue renaming the directory. directoryProperties is optional.
// // User-defined properties to be stored with the file or directory, in the format of a comma-separated list of name and
// // value pairs "n1=v1, n2=v2, ...", where each value is base64 encoded. posixPermissions is optional and only valid if
// // Hierarchical Namespace is enabled for the account. Sets POSIX access permissions for the file owner, the file owning
// // group, and others. Each class may be granted read, write, or execute permission.  The sticky bit is also supported.
// // Both symbolic (rwxrw-rw-) and 4-digit octal notation (e.g. 0766) are supported. posixUmask is only valid if
// // Hierarchical Namespace is enabled for the account. This umask restricts permission settings for file and directory,
// // and will only be applied when default Acl does not exist in parent directory. If the umask bit has set, it means
// // that the corresponding permission will be disabled. Otherwise the corresponding permission will be determined by the
// // permission. A 4-digit octal notation (e.g. 0022) is supported here. If no umask was specified, a default umask -
// // 0027 will be used. cacheControl is cache control for given resource contentType is content type for given resource
// // contentEncoding is content encoding for given resource contentLanguage is content language for given resource
// // contentDisposition is content disposition for given resource leaseID is if specified, the operation only succeeds if
// // the resource's lease is active and matches this ID. sourceLeaseID is a lease ID for the source path. If specified,
// // the source path must have an active lease and the lease ID must match. ifModifiedSince is specify this header value
// // to operate only on a blob if it has been modified since the specified date/time. ifUnmodifiedSince is specify this
// // header value to operate only on a blob if it has not been modified since the specified date/time. ifMatch is specify
// // an ETag value to operate only on blobs with a matching value. ifNoneMatch is specify an ETag value to operate only
// // on blobs without a matching value. sourceIfModifiedSince is specify this header value to operate only on a blob if
// // it has been modified since the specified date/time. sourceIfUnmodifiedSince is specify this header value to operate
// // only on a blob if it has not been modified since the specified date/time. sourceIfMatch is specify an ETag value to
// // operate only on blobs with a matching value. sourceIfNoneMatch is specify an ETag value to operate only on blobs
// // without a matching value. requestID is provides a client-generated, opaque value with a 1 KB character limit that is
// // recorded in the analytics logs when storage analytics logging is enabled.
// func (client directoryClient) Rename(ctx context.Context, renameSource string, timeout *int32, marker *string, directoryProperties *string, posixPermissions *string, posixUmask *string, cacheControl *string, contentType *string, contentEncoding *string, contentLanguage *string, contentDisposition *string, leaseID *string, sourceLeaseID *string, ifModifiedSince *time.Time, ifUnmodifiedSince *time.Time, ifMatch *ETag, ifNoneMatch *ETag, sourceIfModifiedSince *time.Time, sourceIfUnmodifiedSince *time.Time, sourceIfMatch *ETag, sourceIfNoneMatch *ETag, requestID *string) (*DirectoryRenameResponse, error) {
// 	if err := validate([]validation{
// 		{targetValue: timeout,
// 			constraints: []constraint{{target: "timeout", name: null, rule: false,
// 				chain: []constraint{{target: "timeout", name: inclusiveMinimum, rule: 0, chain: nil}}}}}}); err != nil {
// 		return nil, err
// 	}
// 	req, err := client.renamePreparer(renameSource, timeout, marker, directoryProperties, posixPermissions, posixUmask, cacheControl, contentType, contentEncoding, contentLanguage, contentDisposition, leaseID, sourceLeaseID, ifModifiedSince, ifUnmodifiedSince, ifMatch, ifNoneMatch, sourceIfModifiedSince, sourceIfUnmodifiedSince, sourceIfMatch, sourceIfNoneMatch, requestID)
// 	if err != nil {
// 		return nil, err
// 	}
// 	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.renameResponder}, req)
// 	if err != nil {
// 		return nil, err
// 	}
// 	return resp.(*DirectoryRenameResponse), err
// }
//
// // renamePreparer prepares the Rename request.
// func (client directoryClient) renamePreparer(renameSource string, timeout *int32, marker *string, directoryProperties *string, posixPermissions *string, posixUmask *string, cacheControl *string, contentType *string, contentEncoding *string, contentLanguage *string, contentDisposition *string, leaseID *string, sourceLeaseID *string, ifModifiedSince *time.Time, ifUnmodifiedSince *time.Time, ifMatch *ETag, ifNoneMatch *ETag, sourceIfModifiedSince *time.Time, sourceIfUnmodifiedSince *time.Time, sourceIfMatch *ETag, sourceIfNoneMatch *ETag, requestID *string) (pipeline.Request, error) {
// 	req, err := pipeline.NewRequest("PUT", client.url, nil)
// 	if err != nil {
// 		return req, pipeline.NewError(err, "failed to create request")
// 	}
// 	params := req.URL.Query()
// 	if timeout != nil {
// 		params.Set("timeout", strconv.FormatInt(int64(*timeout), 10))
// 	}
// 	if marker != nil && len(*marker) > 0 {
// 		params.Set("continuation", *marker)
// 	}
//
// 	if pathRenameMode != PathRenameModeNone {
// 		params.Set("mode", string(client.PathRenameMode))
// 	}
// 	req.URL.RawQuery = params.Encode()
// 	req.Header.Set("x-ms-rename-source", renameSource)
// 	if directoryProperties != nil {
// 		req.Header.Set("x-ms-properties", *directoryProperties)
// 	}
// 	if posixPermissions != nil {
// 		req.Header.Set("x-ms-permissions", *posixPermissions)
// 	}
// 	if posixUmask != nil {
// 		req.Header.Set("x-ms-umask", *posixUmask)
// 	}
// 	if cacheControl != nil {
// 		req.Header.Set("x-ms-cache-control", *cacheControl)
// 	}
// 	if contentType != nil {
// 		req.Header.Set("x-ms-content-type", *contentType)
// 	}
// 	if contentEncoding != nil {
// 		req.Header.Set("x-ms-content-encoding", *contentEncoding)
// 	}
// 	if contentLanguage != nil {
// 		req.Header.Set("x-ms-content-language", *contentLanguage)
// 	}
// 	if contentDisposition != nil {
// 		req.Header.Set("x-ms-content-disposition", *contentDisposition)
// 	}
// 	if leaseID != nil {
// 		req.Header.Set("x-ms-lease-id", *leaseID)
// 	}
// 	if sourceLeaseID != nil {
// 		req.Header.Set("x-ms-source-lease-id", *sourceLeaseID)
// 	}
// 	if ifModifiedSince != nil {
// 		req.Header.Set("If-Modified-Since", (*ifModifiedSince).In(gmt).Format(time.RFC1123))
// 	}
// 	if ifUnmodifiedSince != nil {
// 		req.Header.Set("If-Unmodified-Since", (*ifUnmodifiedSince).In(gmt).Format(time.RFC1123))
// 	}
// 	if ifMatch != nil {
// 		req.Header.Set("If-Match", string(*ifMatch))
// 	}
// 	if ifNoneMatch != nil {
// 		req.Header.Set("If-None-Match", string(*ifNoneMatch))
// 	}
// 	if sourceIfModifiedSince != nil {
// 		req.Header.Set("x-ms-source-if-modified-since", (*sourceIfModifiedSince).In(gmt).Format(time.RFC1123))
// 	}
// 	if sourceIfUnmodifiedSince != nil {
// 		req.Header.Set("x-ms-source-if-unmodified-since", (*sourceIfUnmodifiedSince).In(gmt).Format(time.RFC1123))
// 	}
// 	if sourceIfMatch != nil {
// 		req.Header.Set("x-ms-source-if-match", string(*sourceIfMatch))
// 	}
// 	if sourceIfNoneMatch != nil {
// 		req.Header.Set("x-ms-source-if-none-match", string(*sourceIfNoneMatch))
// 	}
// 	req.Header.Set("x-ms-version", ServiceVersion)
// 	if requestID != nil {
// 		req.Header.Set("x-ms-client-request-id", *requestID)
// 	}
// 	return req, nil
// }
//
// // renameResponder handles the response to the Rename request.
// func (client directoryClient) renameResponder(resp pipeline.Response) (pipeline.Response, error) {
// 	err := validateResponse(resp, http.StatusOK, http.StatusCreated)
// 	if resp == nil {
// 		return nil, err
// 	}
// 	io.Copy(ioutil.Discard, resp.Response().Body)
// 	resp.Response().Body.Close()
// 	return &DirectoryRenameResponse{rawResponse: resp.Response()}, err
// }
//
// // SetAccessControl set the owner, group, permissions, or access control list for a directory.
// //
// // timeout is the timeout parameter is expressed in seconds. For more information, see <a
// // href="https://docs.microsoft.com/en-us/rest/api/storageservices/fileservices/setting-timeouts-for-blob-service-operations">Setting
// // Timeouts for Blob Service Operations.</a> leaseID is if specified, the operation only succeeds if the resource's
// // lease is active and matches this ID. owner is optional. The owner of the blob or directory. group is optional. The
// // owning group of the blob or directory. posixPermissions is optional and only valid if Hierarchical Namespace is
// // enabled for the account. Sets POSIX access permissions for the file owner, the file owning group, and others. Each
// // class may be granted read, write, or execute permission.  The sticky bit is also supported.  Both symbolic
// // (rwxrw-rw-) and 4-digit octal notation (e.g. 0766) are supported. posixACL is sets POSIX access control rights on
// // files and directories. The value is a comma-separated list of access control entries. Each access control entry
// // (ACE) consists of a scope, a type, a user or group identifier, and permissions in the format
// // "[scope:][type]:[id]:[permissions]". ifMatch is specify an ETag value to operate only on blobs with a matching
// // value. ifNoneMatch is specify an ETag value to operate only on blobs without a matching value. ifModifiedSince is
// // specify this header value to operate only on a blob if it has been modified since the specified date/time.
// // ifUnmodifiedSince is specify this header value to operate only on a blob if it has not been modified since the
// // specified date/time. requestID is provides a client-generated, opaque value with a 1 KB character limit that is
// // recorded in the analytics logs when storage analytics logging is enabled.
// func (client directoryClient) SetAccessControl(ctx context.Context, timeout *int32, leaseID *string, owner *string, group *string, posixPermissions *string, posixACL *string, ifMatch *ETag, ifNoneMatch *ETag, ifModifiedSince *time.Time, ifUnmodifiedSince *time.Time, requestID *string) (*DirectorySetAccessControlResponse, error) {
// 	if err := validate([]validation{
// 		{targetValue: timeout,
// 			constraints: []constraint{{target: "timeout", name: null, rule: false,
// 				chain: []constraint{{target: "timeout", name: inclusiveMinimum, rule: 0, chain: nil}}}}}}); err != nil {
// 		return nil, err
// 	}
// 	req, err := client.setAccessControlPreparer(timeout, leaseID, owner, group, posixPermissions, posixACL, ifMatch, ifNoneMatch, ifModifiedSince, ifUnmodifiedSince, requestID)
// 	if err != nil {
// 		return nil, err
// 	}
// 	resp, err := client.Pipeline().Do(ctx, responderPolicyFactory{responder: client.setAccessControlResponder}, req)
// 	if err != nil {
// 		return nil, err
// 	}
// 	return resp.(*DirectorySetAccessControlResponse), err
// }
//
// // setAccessControlPreparer prepares the SetAccessControl request.
// func (client directoryClient) setAccessControlPreparer(timeout *int32, leaseID *string, owner *string, group *string, posixPermissions *string, posixACL *string, ifMatch *ETag, ifNoneMatch *ETag, ifModifiedSince *time.Time, ifUnmodifiedSince *time.Time, requestID *string) (pipeline.Request, error) {
// 	req, err := pipeline.NewRequest("PATCH", client.url, nil)
// 	if err != nil {
// 		return req, pipeline.NewError(err, "failed to create request")
// 	}
// 	params := req.URL.Query()
// 	if timeout != nil {
// 		params.Set("timeout", strconv.FormatInt(int64(*timeout), 10))
// 	}
// 	params.Set("action", "setAccessControl")
// 	req.URL.RawQuery = params.Encode()
// 	if leaseID != nil {
// 		req.Header.Set("x-ms-lease-id", *leaseID)
// 	}
// 	if owner != nil {
// 		req.Header.Set("x-ms-owner", *owner)
// 	}
// 	if group != nil {
// 		req.Header.Set("x-ms-group", *group)
// 	}
// 	if posixPermissions != nil {
// 		req.Header.Set("x-ms-permissions", *posixPermissions)
// 	}
// 	if posixACL != nil {
// 		req.Header.Set("x-ms-acl", *posixACL)
// 	}
// 	if ifMatch != nil {
// 		req.Header.Set("If-Match", string(*ifMatch))
// 	}
// 	if ifNoneMatch != nil {
// 		req.Header.Set("If-None-Match", string(*ifNoneMatch))
// 	}
// 	if ifModifiedSince != nil {
// 		req.Header.Set("If-Modified-Since", (*ifModifiedSince).In(gmt).Format(time.RFC1123))
// 	}
// 	if ifUnmodifiedSince != nil {
// 		req.Header.Set("If-Unmodified-Since", (*ifUnmodifiedSince).In(gmt).Format(time.RFC1123))
// 	}
// 	if requestID != nil {
// 		req.Header.Set("x-ms-client-request-id", *requestID)
// 	}
// 	req.Header.Set("x-ms-version", ServiceVersion)
// 	return req, nil
// }
//
// // setAccessControlResponder handles the response to the SetAccessControl request.
// func (client directoryClient) setAccessControlResponder(resp pipeline.Response) (pipeline.Response, error) {
// 	err := validateResponse(resp, http.StatusOK)
// 	if resp == nil {
// 		return nil, err
// 	}
// 	io.Copy(ioutil.Discard, resp.Response().Body)
// 	resp.Response().Body.Close()
// 	return &DirectorySetAccessControlResponse{rawResponse: resp.Response()}, err
// }
